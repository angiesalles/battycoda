<!-- Segmentation JavaScript -->
<script>
    // Global variables
    // With the new player architecture, we don't have a direct wavesurfer reference anymore
    // Instead we access the player through the waveformPlayers global object
    let currentSelection = null;
    let isEditing = false;
    
    // DOM elements
    const segmentsList = document.getElementById('segments-list');
    const segmentsCount = document.getElementById('segments-count');
    const noSegmentsMessage = document.getElementById('no-segments-message');
    const segmentFormCard = document.getElementById('segment-form-card');
    const segmentForm = document.getElementById('segment-form');
    const segmentFormTitle = document.getElementById('segment-form-title');
    const segmentId = document.getElementById('segment-id');
    const segmentName = document.getElementById('segment-name');
    const segmentOnset = document.getElementById('segment-onset');
    const segmentOffset = document.getElementById('segment-offset');
    const segmentNotes = document.getElementById('segment-notes');
    
    // Buttons
    const cancelSegmentBtn = document.getElementById('cancel-segment-btn');
    
    // Initialize segments from JSON data
    let segments = {{ segments_json|safe }};
    console.log("Initial segments data:", segments);
    
    // Event listeners for buttons
    
    cancelSegmentBtn.addEventListener('click', () => {
        hideSegmentForm();
    });
    
    // Form submission handler
    segmentForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        console.log("Form submitted", e);
        
        const formData = new FormData(segmentForm);
        const segmentIdValue = segmentId.value;
        
        // Debug - log all form data
        console.log("Form ID:", segmentIdValue);
        for (let [key, value] of formData.entries()) {
            console.log(`${key}: ${value}`);
        }
        
        try {
            let url, method;
            
            if (segmentIdValue) {
                // Edit existing segment
                url = `/segments/${segmentIdValue}/edit/`;
                method = 'POST';
            } else {
                // Add new segment
                url = `/segments/{{ recording.id }}/add/`;
                method = 'POST';
            }
            
            // Add CSRF token
            if (!formData.has('csrfmiddlewaretoken')) {
                formData.append('csrfmiddlewaretoken', document.querySelector('input[name="csrfmiddlewaretoken"]').value);
            }
            
            const response = await fetch(url, {
                method: method,
                body: formData,
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                if (!segmentIdValue) {
                    // Add new segment to our data array
                    segments.push(data.segment);
                } else {
                    // Update existing segment in our data array
                    const index = segments.findIndex(s => s.id == data.segment.id);
                    if (index !== -1) {
                        segments[index] = data.segment;
                    }
                }
                
                console.log("Form submission successful, updating UI");
                
                // Update the entire UI
                refreshSegmentDisplay();
                
                // Hide the form
                hideSegmentForm();
                
                // Show success message
                showMessage('success', segmentIdValue ? 'Segment updated successfully.' : 'Segment added successfully.');
            } else {
                showMessage('danger', data.error || 'An error occurred.');
            }
        } catch (error) {
            console.error('Error:', error);
            showMessage('danger', 'An error occurred while saving the segment.');
        }
    });
    
    // Initialize event handlers for all segments
    document.addEventListener('DOMContentLoaded', () => {
        // Initialize segments display from the beginning
        refreshSegmentDisplay();
        
        // Create tasks button handler
        const createTasksBtn = document.getElementById('create-tasks-btn');
        if (createTasksBtn) {
            createTasksBtn.addEventListener('click', () => {
                window.location.href = `/recordings/{{ recording.id }}/create-tasks/`;
            });
        }
        
        // Get selection from waveform player and create segment automatically
        // The new waveform player exposes selection via the waveformPlayers global object
        let lastSelection = null;
        let endButtonClicked = false;
        
        // Function to check and process a complete selection
        const processCompleteSelection = (selection) => {
            // Only proceed if we have a complete selection and it's new (to avoid duplicates)
            if (selection.start !== null && selection.end !== null) {
                const selectionString = `${selection.start}-${selection.end}`;
                if (lastSelection !== selectionString || endButtonClicked) {
                    currentSelection = {
                        start: selection.start,
                        end: selection.end
                    };
                    
                    // Store the last selection to avoid duplicates
                    lastSelection = selectionString;
                    endButtonClicked = false;
                    
                    // Automatically create the segment
                    createSegmentFromSelection(selection.start, selection.end);
                }
            }
        };
        
        // Monitor "Set End" button clicks
        const setEndBtn = document.getElementById('segment-waveform-set-end-btn');
        if (setEndBtn) {
            setEndBtn.addEventListener('click', () => {
                // Flag that the end button was clicked to ensure we create a segment
                endButtonClicked = true;
            });
        }
        
        // Periodically check for complete selections
        const checkSelection = () => {
            if (window.waveformPlayers && window.waveformPlayers['segment-waveform']) {
                const selection = window.waveformPlayers['segment-waveform'].getSelection();
                processCompleteSelection(selection);
            }
        };
        
        // Function to automatically create a segment from selection
        function createSegmentFromSelection(start, end) {
            // Create a segment with default values
            const segmentName = `Segment ${new Date().toISOString().slice(11, 19)}`;
            
            // Create form data
            const formData = new FormData();
            formData.append('csrfmiddlewaretoken', document.querySelector('input[name="csrfmiddlewaretoken"]').value);
            formData.append('name', segmentName);
            formData.append('onset', start.toFixed(6));
            formData.append('offset', end.toFixed(6));
            formData.append('notes', '');
            
            console.log('Creating segment with:', {
                name: segmentName,
                onset: start.toFixed(6),
                offset: end.toFixed(6)
            });
            
            // Send the request to create a segment
            fetch(`/segments/{{ recording.id }}/add/`, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => {
                console.log('Server response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('Server response data:', data);
                if (data.success) {
                    // Add the new segment to our segments array
                    segments.push(data.segment);
                    
                    // Update the entire UI
                    refreshSegmentDisplay();
                    
                    // Show success message
                    showMessage('success', 'Segment added automatically.');
                } else {
                    showMessage('danger', data.error || 'An error occurred.');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showMessage('danger', 'An error occurred while saving the segment.');
            });
        }
        
        // Check for selection periodically
        setInterval(checkSelection, 500);
        
        // Update segments display initially
        updateSegmentsDisplay();
    });
    
    // Function to add event listeners to a segment row
    function addSegmentButtonListeners(row) {
        // Play button
        const playBtn = row.querySelector('.play-segment-btn');
        if (playBtn) {
            playBtn.addEventListener('click', () => {
                const onset = parseFloat(playBtn.dataset.onset);
                const offset = parseFloat(playBtn.dataset.offset);
                wavesurfer.play(onset, offset);
            });
        }
        
        // Edit button
        const editBtn = row.querySelector('.edit-segment-btn');
        if (editBtn) {
            editBtn.addEventListener('click', () => {
                const segmentId = editBtn.dataset.segmentId;
                const segmentName = editBtn.dataset.segmentName;
                const segmentOnset = parseFloat(editBtn.dataset.segmentOnset);
                const segmentOffset = parseFloat(editBtn.dataset.segmentOffset);
                const segmentNotes = editBtn.dataset.segmentNotes;
                
                showSegmentForm('edit', {
                    id: segmentId,
                    name: segmentName,
                    onset: segmentOnset,
                    offset: segmentOffset,
                    notes: segmentNotes
                });
            });
        }
        
        // Delete button
        const deleteBtn = row.querySelector('.delete-segment-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', async () => {
                const segmentId = deleteBtn.dataset.segmentId;
                
                if (confirm('Are you sure you want to delete this segment?')) {
                    try {
                        const formData = new FormData();
                        
                        // Add CSRF token
                        const csrfToken = document.querySelector('input[name="csrfmiddlewaretoken"]').value;
                        formData.append('csrfmiddlewaretoken', csrfToken);
                        
                        const response = await fetch(`/segments/${segmentId}/delete/`, {
                            method: 'POST',
                            body: formData,
                            headers: {
                                'X-Requested-With': 'XMLHttpRequest'
                            }
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            // Remove the segment from our data array
                            segments = segments.filter(segment => segment.id != segmentId);
                            
                            // Update the entire UI
                            refreshSegmentDisplay();
                            
                            // Show success message
                            showMessage('success', 'Segment deleted successfully.');
                        } else {
                            showMessage('danger', data.error || 'An error occurred.');
                        }
                    } catch (error) {
                        console.error('Error:', error);
                        showMessage('danger', 'An error occurred while deleting the segment.');
                    }
                }
            });
        }
    }
    
    // Function to show the segment form
    function showSegmentForm(mode, data) {
        // Set form title
        segmentFormTitle.textContent = mode === 'add' ? 'Add Segment' : 'Edit Segment';
        
        // Set form values
        segmentId.value = data.id || '';
        segmentName.value = data.name || '';
        segmentOnset.value = data.onset.toFixed(6);
        segmentOffset.value = data.offset.toFixed(6);
        segmentNotes.value = data.notes || '';
        
        // Show the form
        segmentFormCard.style.display = 'block';
        
        // Scroll to the form
        segmentFormCard.scrollIntoView({ behavior: 'smooth' });
        
        // Set editing flag
        isEditing = true;
    }
    
    // Function to hide the segment form
    function hideSegmentForm() {
        console.log("Hiding segment form");
        segmentFormCard.style.display = 'none';
        segmentForm.reset();
        isEditing = false;
    }
    
    /**
     * Central function to refresh all segment displays
     * This updates both the segments list and the waveform player visualization
     */
    function refreshSegmentDisplay() {
        console.log("Refreshing segment display with", segments.length, "segments");
        
        // 1. Update segments list in the UI
        if (segmentsList) {
            // Clear existing list
            segmentsList.innerHTML = '';
            
            // Add each segment to the list
            segments.forEach(segment => {
                const row = document.createElement('tr');
                row.id = `segment-row-${segment.id}`;
                row.dataset.segmentId = segment.id;
                row.innerHTML = `
                    <td>${segment.id}</td>
                    <td>${segment.onset.toFixed(2)}s - ${segment.offset.toFixed(2)}s</td>
                    <td>${(segment.offset - segment.onset).toFixed(2)}s</td>
                    <td>
                        <div class="btn-group btn-group-sm">
                            <button class="btn btn-outline-primary play-segment-btn" 
                                    data-onset="${segment.onset}" 
                                    data-offset="${segment.offset}">
                                <i class="fas fa-play"></i>
                            </button>
                            <button class="btn btn-outline-warning edit-segment-btn" 
                                    data-segment-id="${segment.id}"
                                    data-segment-name="${segment.name || ''}"
                                    data-segment-onset="${segment.onset}"
                                    data-segment-offset="${segment.offset}"
                                    data-segment-notes="${segment.notes || ''}">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="btn btn-outline-danger delete-segment-btn" 
                                    data-segment-id="${segment.id}">
                                <i class="fas fa-trash-alt"></i>
                            </button>
                        </div>
                    </td>
                `;
                segmentsList.appendChild(row);
                
                // Add event listeners to buttons
                addSegmentButtonListeners(row);
            });
        }
        
        // 2. Update segments count and visibility
        updateSegmentsDisplay();
        
        // 3. Update waveform player with current segments
        if (window.waveformPlayers && window.waveformPlayers['segment-waveform']) {
            console.log("Found waveform player");
            const player = window.waveformPlayers['segment-waveform'];
            console.log("Player object:", player);
            
            // Keep the original segment format with onset/offset
            // The player needs these property names for timeline rendering
            const playerSegments = segments.map(segment => ({
                id: segment.id,
                onset: segment.onset,
                offset: segment.offset
            }));
            console.log("Player segments to set:", playerSegments);
            
            // Update player segments and redraw
            player.setSegments(playerSegments);
        } else {
            console.error("Waveform player not found in window.waveformPlayers");
        }
    }
    
    // Function to update segments display
    function updateSegmentsDisplay() {
        // Get table and count
        const table = document.querySelector('#segments-container .table-responsive');
        const count = segmentsList ? segmentsList.querySelectorAll('tr').length : 0;
        
        // Update count
        if (segmentsCount) {
            segmentsCount.textContent = count;
        }
        
        // Show/hide table and message
        if (table && noSegmentsMessage) {
            if (count > 0) {
                table.style.display = 'block';
                noSegmentsMessage.style.display = 'none';
                
                // Enable create tasks button
                const createTasksBtn = document.getElementById('create-tasks-btn');
                if (createTasksBtn) {
                    createTasksBtn.disabled = false;
                }
            } else {
                table.style.display = 'none';
                noSegmentsMessage.style.display = 'block';
                
                // Disable create tasks button
                const createTasksBtn = document.getElementById('create-tasks-btn');
                if (createTasksBtn) {
                    createTasksBtn.disabled = true;
                }
            }
        }
    }
    
    // Function to show a message
    function showMessage(type, message) {
        const messagesContainer = document.querySelector('.messages');
        
        if (messagesContainer) {
            // Create alert
            const alert = document.createElement('div');
            alert.className = `alert alert-${type} alert-dismissible fade show`;
            alert.role = 'alert';
            alert.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;
            
            // Add to container
            messagesContainer.appendChild(alert);
            
            // Auto-dismiss after 5 seconds
            setTimeout(() => {
                if (alert.parentNode) {
                    alert.remove();
                }
            }, 5000);
        }
    }
</script>