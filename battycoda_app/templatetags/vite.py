"""
Django template tags for loading Vite-bundled assets.

In development mode, assets are loaded from the Vite dev server (port 5173).
In production mode, assets are loaded from the manifest file generated by Vite build.

Usage in templates:
    {% load vite %}
    {% vite_asset 'static/js/main.js' %}                    <!-- Loads a JS entry point -->
    {% vite_asset 'static/js/cluster_explorer/index.js' %}  <!-- Loads a feature bundle -->
    {% vite_css 'styles' %}                                 <!-- Loads a CSS entry point -->
    {% vite_hmr %}                                          <!-- Injects HMR client in dev mode -->
    {% vite_theme_urls %}                                   <!-- Injects theme URL mapping for JS -->

Note: The entry_name for vite_asset should match the key in vite.config.js input object,
which corresponds to the file path (e.g., 'static/js/main.js').

CSP Nonce Support:
    When CSP_STRICT_MODE is enabled, script tags include nonce attributes from request.csp_nonce.
    This allows scripts to execute without 'unsafe-inline' in the CSP policy.
"""

import json
from pathlib import Path

from django import template
from django.conf import settings
from django.templatetags.static import static
from django.utils.safestring import mark_safe

register = template.Library()


def get_csp_nonce(context):
    """Get CSP nonce from request context if available and strict mode is enabled."""
    if not getattr(settings, "CSP_STRICT_MODE", False):
        return None
    request = context.get("request")
    if request and hasattr(request, "csp_nonce"):
        return request.csp_nonce
    return None


def make_script_tag(src, module=True, nonce=None):
    """Generate a script tag with optional nonce attribute."""
    type_attr = ' type="module"' if module else ""
    nonce_attr = f' nonce="{nonce}"' if nonce else ""
    return f'<script{type_attr} src="{src}"{nonce_attr}></script>'


def make_inline_script_tag(content, nonce=None):
    """Generate an inline script tag with optional nonce attribute."""
    nonce_attr = f' nonce="{nonce}"' if nonce else ""
    return f"<script{nonce_attr}>{content}</script>"


# Cache for manifest to avoid repeated file reads
_manifest_cache = None


def get_vite_manifest():
    """Load and cache the Vite manifest file."""
    global _manifest_cache
    if _manifest_cache is not None:
        return _manifest_cache

    # Check multiple possible locations for the manifest
    possible_paths = [
        # Production: manifest collected to staticfiles
        Path(settings.STATIC_ROOT) / "dist" / ".vite" / "manifest.json",
        # Development: manifest in source static folder
        Path(settings.BASE_DIR) / "static" / "dist" / ".vite" / "manifest.json",
    ]

    for manifest_path in possible_paths:
        if manifest_path.exists():
            _manifest_cache = json.loads(manifest_path.read_text())
            return _manifest_cache

    return None


def is_vite_dev_mode():
    """Check if we're in Vite development mode."""
    return settings.DEBUG and getattr(settings, "VITE_DEV_MODE", True)


@register.simple_tag(takes_context=True)
def vite_asset(context, entry_name):
    """
    Load a Vite JS asset, handling dev vs prod environments.

    Args:
        context: Template context (for CSP nonce access)
        entry_name: The entry point path as used in vite.config.js input
                    (e.g., 'static/js/main.js', 'static/js/cluster_explorer/index.js')

    Returns:
        HTML script tag(s) for the entry point and any CSS dependencies.
    """
    nonce = get_csp_nonce(context)

    if is_vite_dev_mode():
        # In dev, load from Vite dev server using the original file path
        # Vite serves files from their source locations
        script_url = f"http://localhost:5173/{entry_name}"
        return mark_safe(make_script_tag(script_url, module=True, nonce=nonce))

    # In production, read from manifest
    manifest = get_vite_manifest()
    if not manifest:
        # Fallback if no manifest exists
        return mark_safe(f"<!-- Vite manifest not found for {entry_name} -->")

    # Find the entry in manifest - key matches the input path from vite.config.js
    # e.g., "static/js/cluster_explorer/index.js" -> { file: "clusterExplorer-xxx.js", ... }
    if entry_name not in manifest:
        return mark_safe(f"<!-- Vite entry {entry_name} not found in manifest -->")

    entry = manifest[entry_name]
    tags = []

    # Add CSS imports if any
    if "css" in entry:
        for css_file in entry["css"]:
            css_url = static(f"dist/{css_file}")
            tags.append(f'<link rel="stylesheet" href="{css_url}">')

    # Add the main script
    js_url = static(f"dist/{entry['file']}")
    tags.append(make_script_tag(js_url, module=True, nonce=nonce))

    return mark_safe("\n".join(tags))


@register.simple_tag
def vite_css(entry_name):
    """
    Load a Vite CSS asset, handling dev vs prod environments.

    Args:
        entry_name: The CSS entry point name (e.g., 'styles' for static/css/main.css)

    Returns:
        HTML link tag for the CSS file.
    """
    if is_vite_dev_mode():
        # In dev, load CSS directly from static (Vite injects via HMR)
        css_url = static("css/main.css")
        return mark_safe(f'<link rel="stylesheet" href="{css_url}">')

    # In production, read from manifest
    manifest = get_vite_manifest()
    if not manifest:
        # Fallback to static file
        css_url = static("css/main.css")
        return mark_safe(f'<link rel="stylesheet" href="{css_url}">')

    # Find the CSS entry in manifest
    entry_key = "static/css/main.css"
    if entry_key not in manifest:
        css_url = static("css/main.css")
        return mark_safe(f'<link rel="stylesheet" href="{css_url}">')

    entry = manifest[entry_key]
    css_url = static(f"dist/{entry['file']}")
    return mark_safe(f'<link rel="stylesheet" href="{css_url}">')


@register.simple_tag(takes_context=True)
def vite_theme_urls(context):
    """
    Generate a JavaScript object with theme name -> URL mapping.

    This allows the theme-switcher.js to load the correct URLs for themes
    in both development and production modes.

    Args:
        context: Template context (for CSP nonce access)

    Returns:
        HTML script tag with window.__VITE_THEME_URLS__ object.
    """
    nonce = get_csp_nonce(context)
    theme_urls = {}

    if is_vite_dev_mode():
        # In dev mode, use static URLs
        themes = ["light", "dark"]
        for theme in themes:
            theme_urls[theme] = static(f"css/themes/{theme}.css")
    else:
        # In production, get URLs from manifest
        manifest = get_vite_manifest()
        if manifest:
            for key, entry in manifest.items():
                if key.startswith("static/css/themes/") and key.endswith(".css"):
                    # Extract theme name from path
                    theme_name = key.replace("static/css/themes/", "").replace(".css", "")
                    theme_urls[theme_name] = static(f"dist/{entry['file']}")
        else:
            # Fallback to static URLs
            themes = ["light", "dark"]
            for theme in themes:
                theme_urls[theme] = static(f"css/themes/{theme}.css")

    # Output as a script tag with nonce if available
    urls_json = json.dumps(theme_urls)
    return mark_safe(make_inline_script_tag(f"window.__VITE_THEME_URLS__ = {urls_json};", nonce))


@register.simple_tag
def vite_theme_css(theme_name):
    """
    Generate a link tag for a specific theme CSS file.

    Uses Vite manifest URLs in production, static URLs in development.
    Useful for pre-loading the user's preferred theme in the head section.

    Args:
        theme_name: The theme name (e.g., 'blue-sky', 'night-city')

    Returns:
        HTML link tag for the theme CSS file, or empty string for 'default' theme.
    """
    if theme_name == "default":
        return ""

    if is_vite_dev_mode():
        # In dev mode, use static URLs
        css_url = static(f"css/themes/{theme_name}.css")
    else:
        # In production, get URL from manifest
        manifest = get_vite_manifest()
        entry_key = f"static/css/themes/{theme_name}.css"

        if manifest and entry_key in manifest:
            css_url = static(f"dist/{manifest[entry_key]['file']}")
        else:
            # Fallback to static URL
            css_url = static(f"css/themes/{theme_name}.css")

    return mark_safe(f'<link id="theme-css-{theme_name}" rel="stylesheet" href="{css_url}">')


@register.simple_tag(takes_context=True)
def vite_hmr(context):
    """
    Inject the Vite HMR client script in development mode.

    Args:
        context: Template context (for CSP nonce access)

    Returns:
        HTML script tag for HMR client in dev mode, empty string in prod.
    """
    if is_vite_dev_mode():
        nonce = get_csp_nonce(context)
        return mark_safe(make_script_tag("http://localhost:5173/@vite/client", module=True, nonce=nonce))
    return ""


@register.simple_tag(takes_context=True)
def vite_react_refresh(context):
    """
    Inject React Refresh runtime for HMR (if using React).

    Args:
        context: Template context (for CSP nonce access)

    Returns:
        HTML script tag for React Refresh in dev mode, empty string in prod.
    """
    if is_vite_dev_mode():
        nonce = get_csp_nonce(context)
        nonce_attr = f' nonce="{nonce}"' if nonce else ""
        return mark_safe(
            f"""
<script type="module"{nonce_attr}>
  import RefreshRuntime from 'http://localhost:5173/@react-refresh'
  RefreshRuntime.injectIntoGlobalHook(window)
  window.$RefreshReg$ = () => {{}}
  window.$RefreshSig$ = () => (type) => type
  window.__vite_plugin_react_preamble_installed__ = true
</script>
"""
        )
    return ""
